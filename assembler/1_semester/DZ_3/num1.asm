section .bss
 fd resb 4    ;выделяем 4 байта для файлового дескриптора fd
 buf resb 1     ;выделяем 1 байт для buf

section .text:
global _start
_start:
 pop ebx    ;передаём имя файла при запуске программы
 pop ebx    ;так как при запуске передаётся одна строка, то она находится в стеке на третьей позиции
 pop ebx    ;то есть после третьей операции pop регистр ebx указывает на строку с именем файла
             
 mov eax, 5    ;задаём системный вызов sys_open
 mov ecx, 0    ;задаём режим открытия файла, в данном случае открываем файл только для чтения
 mov edx, 0    
 int 0x80
 mov [fd], eax    ;после открытия файла помещаем файловый дескриптор в переменную fd


point:            ;создаём метку point
 mov eax, 3       ;теперь считываем один байт из файла, для этого задаём системный вызов sys_read
 mov ebx, [fd]    ;передаём значение файлового дескриптора
 mov ecx, buf     ;считываем в переменную buf
 mov edx, 1       ;считываем 1 байт
 int 0x80
 
 cmp eax, 1       ;этот системный вызов по результату выполнения возвращает число действительно считанных байт
 je point2        ;это число хранится в eax, поэтому если значение eax равно единице, то есть конец файла еще не достигнут
                  ;перемещаемся к метке point2
 mov eax, 6       ;если же достигнут конец файла, то есть значение eax не равно единице, то закрываем файл
 mov ebx, [fd]    ;для этого используем системный вызов sys_close, через ebx передаём файловый дескриптор
 int 0x80 
 
 mov eax, 1       ;после проделанных операций завершаем программу
 mov ebx, 0
 int 0x80

point2:           ;если значение eax оказалось равным 1, то есть байт файла был успешно считан, то
 mov eax, 4       ;задаём системный вызов sys_write
 mov ebx, 1       ;передаём значение стандартного потока вывода
 mov ecx, buf     ;выводим значение переменной buf
 mov edx, 1       
 int 0x80
 
 jmp point        ;после проделанных операций переходим обратно к метке point
