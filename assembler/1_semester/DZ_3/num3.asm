section .bss
 fd resb 4     ;выделяем 4 байта для файлового дескриптора файла
 buf resb 1    ;выделяем 1 байт для buf

section .text:
global _start
_start:
 pop ebx     ;передаём имя файла при запуске программы
 pop ebx
 pop ebx

 mov eax, 5    ;для открытия файла задаём системный вызов sys_open
 mov ecx, 2    ;задаём режим открытия файла, в данном случае открываем файл и для чтения, и для записи
 mov edx, 0
 int 0x80
 mov [fd], eax    ;после открытия файла помещаем файловый дескриптор в переменную fd
 
point:             ;создаём метку point
 mov eax, 3        ;теперь считываем один байт из файла, для этого задаём системный вызов sys_read
 mov ebx, [fd]     ;передаём значение файлового дескриптора файла
 mov ecx, buf      ;считываем в переменную buf 1 байт
 mov edx, 1
 int 0x80
 
 cmp eax, 1    ;этот системный вызов по результату выполнения возвращает число действительно считанных байт
 jne point2    ;это число хранится в eax, поэтому если значение eax не равно единице, то если достигнут конец файла, то
               ;перемещаемся к метке point2
 mov al, [buf]    ;помещаем значение переменной buf в регистр al
 cmp al, 97       ;сравниваем значение регистра al с числом 97, которое соответствует символу 'a' 
 jl point         ;если значение регистра al меньше 97, то просто переходи к метке point

 cmp al, 123     ;если оказалось, что значение регистра al больше 97, то сравниваем его с числом 123, которое соответствует символу 'z'
 jg point        ;если значение регистра al больше 123, то оно не входит в нужный нам диапазон строчных символов
                 ;поэтому переходим к метке point
 sub al, 32      ;если же значение регистра попало в нужный нам диапазон, то уменьшаем значение регистра на число 32, записыываем полученное значение в  регистр al
 mov [buf], al   ;мы уменьшили значение на 32, потому что числу каждой строчной буквы будет соответствовать число этой же, но уже заглавной буквы, которое меньше ровно на 32
                 ;помещаем новое значение регистра в переменную buf
 mov eax, 19     ;задаём системный вызов sys_lseek, который позволит переместится нам на нужную позицию в файле
 mov ebx, [fd]   ;передаём файловый дескриптор
 mov ecx, -1     ;в edx передаём 1, что означает, что мы хотим сдвинуться относительно текущего положения файлового дескриптора
 mov edx, 1      ;и перемещаемся на -1 позицию относительно текущего положения файлового дескриптора
 int 0x80

 mov eax, 4       ;задаём системный вызов sys_write
 mov ebx, [fd]    ;передаём значение файлового дескриптора 
 mov ecx, buf     ;записываем в файл значение переменной buf
 mov edx, 1
 int 0x80
 jmp point        ;перемещаемся к метке point

point2:           ;как только достигнут конец файла, перемещаемся к метке point2
 mov eax, 6       ;закрываем файл
 mov ebx, [fd]
 int 0x80

 mov eax, 1       ;завершаем выполнение программы
 mov ebx, 0
 int 0x80
