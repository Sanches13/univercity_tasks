section .data
;приветственное сообщение пользователю
 msg db 'Hello! If you enter a one-digit term, then enter 0 before it. E.g. the number 5 should be entered like this: 05', 0xA
 len equ $ - msg
 msg1 db '1', 0      ;помещаем в msg1 символ '1'
 len1 equ $ - msg1

section .bss
 x resb 2    ;выделяем 2 байта для x
 y resb 2    ;выделяем 2 байта для y
 m resb 1    ;выделяем 1 байт для m
 n resb 1    ;выделяем 1 байт для n

section .text:
 global _start
_start:
 mov eax, 4       ;выводим приветственное сообщение пользователю
 mov ebx, 1
 mov ecx, msg
 mov edx, len
 int 0x80

 mov eax, 3       ;считываем первое число, помещаем его в переменную x
 mov ebx, 0
 mov ecx, x 
 mov edx, 3       ;считываем три байта, чтобы ввести следующее число через пробел
 int 0x80
 
 mov eax, 3      ;считываем второе число, помещаем его в переменную y
 mov ebx, 0
 mov ecx, y
 mov edx, 2
 int 0x80

 mov al, [x+1]      ;кладём в регистр al вторую цифру числа x, которая находится по адресу x+1
 sub al, 0x30       ;преобразуем символ в число
 mov ah, [x]        ;кладём в регистр ah первую цифру числа x, которая находится по адресу x
 sub ah, 0x30       ;преобразуем символ в число
 sal al, 4          ;с помощью sal сдвигаем биты al на 4 позиции влево, остальное заполняем нулями
 sal ax, 4          ;с помощью sal сдвигаем биты ax на 4 позиции влево, остальное заполняем нулями
 mov [n], ah        ;с помощью двух предыдущих команд получаем упакованное BCD-число, которое находтся в регистре ah, помещаем его в переменную n

 mov al, [y+1]    ;кладём в регистр al вторую цифру числа x, которая находится по адресу y+1
 sub al, 0x30     ;преобразуем символ в число
 mov ah, [y]      ;кладём в регистр ah первую цифру числа x, которая находится по адресу y
 sub ah, 0x30     ;преобразуем символ в число
 sal al, 4        ;с помощью sal сдвигаем биты al на 4 позиции влево, остальное заполняем нулями
 sal ax, 4        ;с помощью sal сдвигаем биты ax на 4 позиции влево, остальное заполняем нулями
 mov [m], ah      ;с помощью двух предыдущих команд получаем упакованное BCD-число, которое находтся в регистре ah, помещаем его в переменную m

 mov al, [m]     ;помещаем в регистр al первое число
 mov bl, [n]     ;помещаем в регистр bl второе число
 adc al, bl      ;складываем два числа
 daa             ;с помощью daa корректируем полученный результат в правильное двузначное десятичное число
 jc point2       ;если установлен carry flag, то произошел перенос единицы в старший разряд, поэтому перемещаемся к метке point2

point1: 
 xor ah, ah     ;обнуляем значение регистра ah
 sal ax, 4      ;с помощью sal сдвигаем биты ax на 4 позиции влево, остальное заполняем нулями
 sar al, 4      ;с помощью sar сдвигаем биты al на 4 позиции вправо, остальное заполняем знаковым битом
                ;с помощью двух предыдущих операций получаем неупакованное BCD-число, хранящееся в регистре ax
 add al, 0x30   ;преобразуем число в символ
 add ah, 0x30   ;преобразуем число в символ
 mov [n], al    ;помещаем в переменную n значение регистра al, то есть вторую цифру полученного числа
 mov [m], ah    ;помещаем в переменную m значение регистра ah, то есть первую цифру полученного числа
 
 mov eax, 4     ;выводим на экран первую цифру
 mov ebx, 1
 mov ecx, m
 mov edx, 1
 int 0x80

 mov eax, 4     ;выводим на экран вторую цифру
 mov ebx, 1
 mov ecx, n
 mov edx, 1
 int 0x80

 mov eax, 1     ;завершам программу
 mov ebx, 0
 int 0x80

point2:        ;если произошёл перенос единицы в старший разряд, то выводим на экран символ '1'
 mov [n], al   ;помещаем значение регистра al в переменную n
 mov eax, 4
 mov ebx, 1
 mov ecx, msg1
 mov edx, len1
 int 0x80
 mov al, [n]   ;помещаем значение переменной n в регистр al
 jmp point1    ;перемещаемся к метке point1
