section .data
;приветственное сообщение пользователю
 msg db 'Hello! If you enter a one-digit term, then enter 0 before it. E.g. the number 5 should be entered like this: 05', 0xA
 len equ $ - msg
 sign db '-', 0     ;помещаем в sign символ '-'
 len_sign equ $ - sign

section .bss
 x resb 2      ;выделяем 2 байта для x
 y resb 2      ;выделяем 2 байта для y
 n resb 1      ;выделяем 1 байт для m
 m resb 1      ;выделяем 1 байт для n

section .text:
 global _start
_start:
 mov eax, 4      ;выводим приветственное сообщение пользователю
 mov ebx, 1
 mov ecx, msg
 mov edx, len
 int 0x80

 mov eax, 3    ;считываем первое число, помещаем его в переменную x
 mov ebx, 0
 mov ecx, x
 mov edx, 3    ;считываем три байта, чтобы ввести следующее число через пробел
 int 0x80
 
 mov eax, 3     ;считываем второе число, помещаем его в переменную y
 mov ebx, 0 
 mov ecx, y
 mov edx, 2
 int 0x80

 mov al, [x+1]    ;кладём в регистр al вторую цифру числа x, которая находится по адресу x+1
 sub al, 0x30     ;преобразуем символ в число
 mov ah, [x]      ;кладём в регистр ah первую цифру числа x, которая находится по адресу x
 sub ah, 0x30     ;преобразуем символ в число
 sal al, 4        ;с помощью sal сдвигаем биты al на 4 позиции влево, остальное заполняем нулями
 sal ax, 4        ;с помощью sal сдвигаем биты ax на 4 позиции влево, остальное заполняем нулями
 mov [n], ah      ;с помощью двух предыдущих команд получаем упакованное BCD-число, которое находтся в регистре ah, помещаем его в переменную n

 mov al, [y+1]    ;кладём в регистр al вторую цифру числа x, которая находится по адресу y+1
 sub al, 0x30     ;преобразуем символ в число
 mov ah, [y]      ;кладём в регистр ah первую цифру числа x, которая находится по адресу y
 sub ah, 0x30     ;преобразуем символ в число
 sal al, 4        ;с помощью sal сдвигаем биты al на 4 позиции влево, остальное заполняем нулями
 sal ax, 4        ;с помощью sal сдвигаем биты ax на 4 позиции влево, остальное заполняем нулями
 mov [m], ah      ;с помощью двух предыдущих команд получаем упакованное BCD-число, которое находтся в регистре ah, помещаем его в переменную m

 mov al, [n]     ;помещаем в регистр al первое число
 mov bl, [m]     ;помещаем в регистр bl второе число
 sub al, bl      ;вычитаем второе число из первого
 das             ;с помощью das корректируем полученный результат в правильное двузначное десятичное число
 jc point2       ;если установлен carry flag, то перемещаемся к метке point2

point1:
 xor ah, ah      ;обнуляем значение регистра ah
 sal ax, 4       ;с помощью sal сдвигаем биты ax на 4 позиции влево, остальное заполняем нулями
 ror al, 4       ;с помощью ror циклически сдвигаем биты al на 4 позиции вправо
 
 add al, 0x30    ;преобразуем число в символ
 add ah, 0x30    ;преобразуем число в символ
 mov [n], al     ;помещаем в переменную n значение регистра al, то есть вторую цифру полученного числа
 mov [m], ah     ;помещаем в переменную m значение регистра ah, то есть первую цифру полученного числа
  
 mov eax, 4      ;выводим на экран первую цифру
 mov ebx, 1
 mov ecx, m
 mov edx, 1
 int 0x80

 mov eax, 4      ;выводим на экран вторую цифру
 mov ebx, 1
 mov ecx, n
 mov edx, 1
 int 0x80

 mov eax, 1     ;завершам программу
 mov ebx, 0
 int 0x80
                 
point2:         ;если произошёл перенос единицы в старший разряд, то выводим на экран символ '-'
 mov eax, 4     ;получается, что второе число больше первого, резульатом должно быть отрицательное число
 mov ebx, 1
 mov ecx, sign 
 mov edx, len_sign
 int 0x80
                 
 mov al, [m]     ;меняем местами два числа, то есть второе число помещаем в al, а первое в bl
 mov bl, [n]
 sub al, bl      ;вычитаем первое число из второго
 das             ;с помощью das корректируем полученный результат в правильное двузначное десятичное число
 jmp point1      ;перемещаемся к метке point1
