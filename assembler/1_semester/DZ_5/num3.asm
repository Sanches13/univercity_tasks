section .bss
 fd resb 4         ;выделяем 4 байта для файлового дескриптора fd
 x resb 1          ;выделяем 1 байт для x
 ind resb 4        ;выделяем 4 байта для ind
 size resb 4       ;выделяем 4 байта для size
 num resb 4        ;выделяем 4 байта для num
 array resb 10     ;выделяем 10 байт для области, в которой позже будет находиться искомое число

section .text:
 global _start
_start:

 pop ebx      ;передаём имя файла при запуске программы
 pop ebx      ;так как при запуске передаётся одна строка, то она находится в стеке на третьей позиции
 pop ebx      ;то есть после третьей операции pop регистр ebx указывает на строку с именем файла

 mov eax, 0          ;обнуляем значение переменной ind
 mov [ind], eax
 
 mov eax, 5           ;задаём системный вызов sys_open
 mov ecx, 0           ;задаём режим открытия файла, в данном случае открываем файл для чтения
 mov edx, 0
 int 0x80
 mov [fd], eax        ;после открытия файла помещаем файловый дескриптор в переменную fd

 mov eax, 0           ;обнуляем значение переменной size
 mov [size], eax

point:              ;создаём метку point
 mov eax, 3         ;теперь считываем один байт из файла, для этого задаём системный вызов sys_read
 mov ebx, [fd]      ;передаём значение файлового дескриптора
 mov ecx, x         ;считываем в переменную x
 mov edx, 1         ;считываем 1 байт
 int 0x80

 cmp eax, 1         ;этот системный вызов по результату выполнения возвращает число действительно считанных байт
 jne point2         ;это число хранится в eax, поэтому если значение eax равно единице, то есть конец файла еще не достигнут
                    ;перемещаемся к метке point2
 
 mov eax, [size]    ;увеличиваем значение переменной size на 1
 add eax, 1
 mov [size], eax
 jmp point          ;переходим обратно к метке point
 
point2:              ;как только весь файл проанализирован, переходим к метке point2
 mov eax, [size]     ;помещаем в регистр eax размер файла
 cmp eax, 0          ;сравниваем это значение с 0, и в случае равенства переходим к метке point3
 je point3
                      ;для того, чтобы вывести найденное число, будем делить это число на 10 до тех пор, пока число не станет нулём
                      ;остаток от деления, то есть каждую цифру числа, будем записывать в array
 xor edx, edx         ;обнуляем значение регистра edx
 mov ebx, 10          ;помещаем в регистр ebx число 10
 div ebx              ;делим значение регистра eax на значение регистра ebx
 
 mov [size], eax       ;помещаем частное в переменную size
  
 add edx, 0x30         ;остаток от деления, который теперь хранится в edx, переводим в число путем суммирования с 0x30
 mov eax, [ind]        ;в переменной ind хранится индекс, который должен иметь очередной символ в array
 mov edi, array        ;адрес array помещаем в edi
 add edi, eax          ;прибавляем индекс
 mov [edi], edx        ;помещаем полученную цифру числа по адресу в edi
 inc eax               ;увеличиваем значение eax на 1, то есть значение нашего индекса
 mov [ind], eax        ;помещаем значение обратно в переменную ind

 jmp point2            ;переходим к метке point2

point3:             ;теперь выведем полученное число на экран 
 mov edi, array     ;в регистр edi помещаем адрес array, где располагается число
 mov eax, [ind]     ;в регистр eax помещаем значение индекса ind
 cmp eax, 0         ;сравниваем значение с нулём
 jnge exit          ;если значение меньше нуля, то завершаем программу
 add edi, eax       ;прибаляем к адресу в edi значение индекса

 mov eax, [edi]     ;теперь помещаем в eax значение, расположенное по адресу в edi
 mov [num], eax     ;помещаем это значение в переменную num

 mov eax, 4         ;выводим значение на экран
 mov ebx, 1
 mov ecx, num 
 mov edx, 1
 int 0x80

 mov eax, [ind]       ;снова помещаем значение индекса в регистр eax
 dec eax              ;уменьшаем его значение на 1
 mov [ind], eax       ;помещаем полученное значение обратно в переменную 
 jmp point3           ;переходим к метке point3
 
exit:
 mov eax, 6          ;закрываем файл
 mov ebx, [fd]
 int 0x80

 mov eax, 1          ;завершаем программу
 mov ebx, 0 
 int 0x80
